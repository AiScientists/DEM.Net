<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DEM.Net.Core</name>
    </assembly>
    <members>
        <member name="M:DEM.Net.Core.HeightMapExtensions.BakeCoordinates(DEM.Net.Core.HeightMap)">
            <summary>
            Helper to get an in memory coordinate list
            useful to generate normal maps and let the same height map follow the pipeline (reproj, center, ...)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.NetworkHelper.IsNetworkAvailable">
            <summary>
            Indicates whether any network connection is available
            Filter connections below a specified speed, as well as virtual network cards.
            </summary>
            <returns>
                <c>true</c> if a network connection is available; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:DEM.Net.Core.NetworkHelper.IsNetworkAvailable(System.Int64)">
            <summary>
            Indicates whether any network connection is available.
            Filter connections below a specified speed, as well as virtual network cards.
            </summary>
            <param name="minimumSpeed">The minimum speed required. Passing 0 will not filter connection using speed.</param>
            <returns>
                <c>true</c> if a network connection is available; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:DEM.Net.Core.DisposableValueDictionary`2">
            <summary>
            Dictionary with IDisposable values than can be used in a using block
            </summary>
        </member>
        <member name="M:DEM.Net.Core.Imagery.ImageryService.GenerateNormalMap(DEM.Net.Core.HeightMap,System.String)">
            <summary>
            Generate normal texture from height map.
            Note : heightMap should be in projected coordinates (see ReprojectToCartesian())
            </summary>
            <param name="heightMap">heightMap in projected coordinates</param>
            <param name="outputDirectory"></param>
            <returns></returns>
        </member>
        <member name="T:DEM.Net.Core.Imagery.PBRTexture">
            <summary>
            Physical Based Rendering (PBR) set of textures
            - Base color texture
            - Normal map texture
            
            not supported or used in DEM.net
            - Ambient occlusion texture
            - Emissive texture
            </summary>
        </member>
        <member name="T:DEM.Net.Core.Imagery.TileUtils">
            <summary>
            Source : https://docs.microsoft.com/en-us/bingmaps/articles/bing-maps-tile-system
            </summary>
        </member>
        <member name="M:DEM.Net.Core.Imagery.TileUtils.Clip(System.Double,System.Double,System.Double)">
            <summary>
            Clips a number to the specified minimum and maximum values.
            </summary>
            <param name="n">The number to clip.</param>
            <param name="minValue">Minimum allowable value.</param>
            <param name="maxValue">Maximum allowable value.</param>
            <returns>The clipped value.</returns>
        </member>
        <member name="M:DEM.Net.Core.Imagery.TileUtils.MapSize(System.Int32)">
            <summary>
            Determines the map width and height (in pixels) at a specified level
            of detail.
            </summary>
            <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
            to 23 (highest detail).</param>
            <returns>The map width and height in pixels.</returns>
        </member>
        <member name="M:DEM.Net.Core.Imagery.TileUtils.GroundResolution(System.Double,System.Int32)">
            <summary>
            Determines the ground resolution (in meters per pixel) at a specified
            latitude and level of detail.
            </summary>
            <param name="latitude">Latitude (in degrees) at which to measure the
            ground resolution.</param>
            <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
            to 23 (highest detail).</param>
            <returns>The ground resolution, in meters per pixel.</returns>
        </member>
        <member name="M:DEM.Net.Core.Imagery.TileUtils.MapScale(System.Double,System.Int32,System.Int32)">
            <summary>
            Determines the map scale at a specified latitude, level of detail,
            and screen resolution.
            </summary>
            <param name="latitude">Latitude (in degrees) at which to measure the
            map scale.</param>
            <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
            to 23 (highest detail).</param>
            <param name="screenDpi">Resolution of the screen, in dots per inch.</param>
            <returns>The map scale, expressed as the denominator N of the ratio 1 : N.</returns>
        </member>
        <member name="M:DEM.Net.Core.Imagery.TileUtils.LatLongToPixelXY(System.Double,System.Double,System.Int32)">
            <summary>
            Converts a point from latitude/longitude WGS-84 coordinates (in degrees)
            into pixel XY coordinates at a specified level of detail.
            </summary>
            <param name="latitude">Latitude of the point, in degrees.</param>
            <param name="longitude">Longitude of the point, in degrees.</param>
            <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
            to 23 (highest detail).</param>
            <param name="pixelX">Output parameter receiving the X coordinate in pixels.</param>
            <param name="pixelY">Output parameter receiving the Y coordinate in pixels.</param>
        </member>
        <member name="M:DEM.Net.Core.Imagery.TileUtils.PixelXYToLatLong(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts a pixel from pixel XY coordinates at a specified level of detail
            into latitude/longitude WGS-84 coordinates (in degrees).
            </summary>
            <param name="pixelX">X coordinate of the point, in pixels.</param>
            <param name="pixelY">Y coordinates of the point, in pixels.</param>
            <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
            to 23 (highest detail).</param>
            <param name="latitude">Output parameter receiving the latitude in degrees.</param>
            <param name="longitude">Output parameter receiving the longitude in degrees.</param>
        </member>
        <!-- Commentaire XML incorrect pour le membre "M:DEM.Net.Core.Imagery.TileUtils.PixelXYToTileXY(System.Int32,System.Int32)" -->
        <!-- Commentaire XML incorrect pour le membre "M:DEM.Net.Core.Imagery.TileUtils.TileXYToPixelXY(System.Int32,System.Int32)" -->
        <member name="M:DEM.Net.Core.Imagery.TileUtils.TileXYToQuadKey(System.Int32,System.Int32,System.Int32)">
            <summary>
            Converts tile XY coordinates into a QuadKey at a specified level of detail.
            </summary>
            <param name="tileX">Tile X coordinate.</param>
            <param name="tileY">Tile Y coordinate.</param>
            <param name="levelOfDetail">Level of detail, from 1 (lowest detail)
            to 23 (highest detail).</param>
            <returns>A string containing the QuadKey.</returns>
        </member>
        <member name="M:DEM.Net.Core.Imagery.TileUtils.QuadKeyToTileXY(System.String,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Converts a QuadKey into tile XY coordinates.
            </summary>
            <param name="quadKey">QuadKey of the tile.</param>
            <param name="tileX">Output parameter receiving the tile X coordinate.</param>
            <param name="tileY">Output parameter receiving the tile Y coordinate.</param>
            <param name="levelOfDetail">Output parameter receiving the level of detail.</param>
        </member>
        <member name="T:DEM.Net.Core.HGTFile">
            <summary>
            SRTM height file
            https://wiki.openstreetmap.org/wiki/SRTM
            
            Official documentation : https://dds.cr.usgs.gov/srtm/version2_1/Documentation/SRTM_Topo.pdf
            </summary>
        </member>
        <member name="P:DEM.Net.Core.DEMDataSet.VRTFileUrl">
            <summary>
            GDAL Virtual 
            </summary>
        </member>
        <member name="P:DEM.Net.Core.DEMDataSet.SRTM_GL3">
            <summary>
            Shuttle Radar Topography Mission (SRTM GL3) Global 90m
            </summary>
        </member>
        <member name="P:DEM.Net.Core.DEMDataSet.SRTM_GL1">
            <summary>
            Shuttle Radar Topography Mission (SRTM GL1) Global 30m
            </summary>
        </member>
        <member name="P:DEM.Net.Core.DEMDataSet.AW3D30">
            <summary>
            ALOS World 3D - 30m
            </summary>
        </member>
        <member name="T:DEM.Net.Core.FileMetadata">
            <summary>
            Metadata file generated on the fly.
            Extracts necessary data in order to index files for querying without actually open them (which is costly)
            </summary>
        </member>
        <member name="P:DEM.Net.Core.GeoPoint.DistanceFromOriginMeters">
            <summary>
            When this point is part of a List and ComputePointsDistances is called, this field
            stores the distance from this point to origin point in meters.
            </summary>
        </member>
        <member name="P:DEM.Net.Core.HeightMap.Count">
            <summary>
            Coordinate count
            </summary>
        </member>
        <member name="M:DEM.Net.Core.DouglasPeucker.DouglasPeuckerReduction(System.Collections.Generic.List{DEM.Net.Core.GeoPoint},System.Double)">
            <summary>
            Uses the Douglas Peucker algorithim to reduce the number of points.
            </summary>
            <param name="Points">The points.</param>
            <param name="Tolerance">The tolerance.</param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.DouglasPeucker.DouglasPeuckerReduction(System.Collections.Generic.List{DEM.Net.Core.GeoPoint},System.Int32,System.Int32,System.Double,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Douglases the peucker reduction.
            </summary>
            <param name="points">The points.</param>
            <param name="firstPoint">The first point.</param>
            <param name="lastPoint">The last point.</param>
            <param name="tolerance">The tolerance.</param>
            <param name="pointIndexsToKeep">The point indexs to keep.</param>
        </member>
        <member name="M:DEM.Net.Core.DouglasPeucker.PerpendicularDistance(DEM.Net.Core.GeoPoint,DEM.Net.Core.GeoPoint,DEM.Net.Core.GeoPoint)">
            <summary>
            The distance of a point from a line made from point1 and point2.
            </summary>
            <param name="pt1">The PT1.</param>
            <param name="pt2">The PT2.</param>
            <param name="p">The p.</param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.ElevationService.GetLineGeometryElevation(System.String,DEM.Net.Core.DEMDataSet,DEM.Net.Core.InterpolationMode)">
            <summary>
            Extract elevation data along line path
            </summary>
            <param name="lineWKT"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.ElevationService.GetElevationData(System.Collections.Generic.IEnumerable{DEM.Net.Core.GeoPoint},DEM.Net.Core.DEMDataSet,DEM.Net.Core.RasterFileDictionary,System.Collections.Generic.List{DEM.Net.Core.FileMetadata},DEM.Net.Core.IInterpolator)">
            <summary>
            Fill altitudes for each GeoPoint provided, opening as few rasters as possible
            </summary>
            <param name="intersections"></param>
            <param name="segTiles"></param>
        </member>
        <member name="M:DEM.Net.Core.ElevationService.FindSegmentIntersections(System.Double,System.Double,System.Double,System.Double,System.Collections.Generic.List{DEM.Net.Core.FileMetadata},System.Boolean,System.Boolean)">
            <summary>
            Finds all intersections between given segment and DEM grid
            </summary>
            <param name="startLon">Segment start longitude</param>
            <param name="startLat">Segment start latitude</param>
            <param name="endLon">Segment end longitude</param>
            <param name="endLat">Segment end latitude</param>
            <param name="segTiles">Metadata files <see cref="!:RasterService.GetCoveringFiles"/> to see how to get them relative to segment geometry</param>
            <param name="returnStartPoint">If true, the segment starting point will be returned. Useful when processing a line segment by segment.</param>
            <param name="returnEndPoind">If true, the segment end point will be returned. Useful when processing a line segment by segment.</param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.DownloadMissingFiles(DEM.Net.Core.DEMDataSet,DEM.Net.Core.BoundingBox)">
            <summary>
            Given a bounding box and a dataset, downloads all covered tiles
            using VRT file specified in dataset
            </summary>
            <param name="dataSet">DEMDataSet used</param>
            <param name="bbox">Bounding box, <see cref="M:DEM.Net.Core.GeometryService.GetBoundingBox(System.String)"/></param>
            <remarks>VRT file is downloaded once. It will be cached in local for 30 days.
            </remarks>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.DownloadMissingFiles(DEM.Net.Core.DEMDataSet,System.Double,System.Double)">
            <summary>
            Given a location and a dataset, downloads all covered tiles
            using VRT file specified in dataset
            </summary>
            <param name="dataSet">DEMDataSet used</param>
            <param name="lat">Latitude of location</param>
            <param name="lon">Longitude of location</param>
            <remarks>VRT file is downloaded once. It will be cached in local for 30 days.
            </remarks>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.DownloadMissingFiles(DEM.Net.Core.DEMDataSet,DEM.Net.Core.GeoPoint)">
            <summary>
            Given a location and a dataset, downloads all covered tiles
            using VRT file specified in dataset
            </summary>
            <param name="dataSet">DEMDataSet used</param>
            <param name="geoPoint">GeoPoint</param>
            <remarks>VRT file is downloaded once. It will be cached in local for 30 days.
            </remarks>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.GetLineGeometryElevation(System.Collections.Generic.IEnumerable{DEM.Net.Core.GeoPoint},DEM.Net.Core.DEMDataSet,DEM.Net.Core.InterpolationMode)">
            <summary>
            High level method that retrieves all dataset elevations along given line
            </summary>
            <param name="lineGeoPoints">List of points that, when joined, makes the input line</param>
            <param name="dataSet">DEM dataset to use</param>
            <param name="interpolationMode">Interpolation mode</param>
            <remarks>Output can be BIG, as all elevations will be returned.</remarks>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.GetLineGeometryElevation(GeoAPI.Geometries.IGeometry,DEM.Net.Core.DEMDataSet,DEM.Net.Core.InterpolationMode)">
            <summary>
            High level method that retrieves all dataset elevations along given line
            </summary>
            <param name="lineStringGeometry">Line geometry</param>
            <param name="dataSet">DEM dataset to use</param>
            <param name="interpolationMode">Interpolation mode</param>
            <remarks>Output can be BIG, as all elevations will be returned.</remarks>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.GetLineGeometryElevation(System.String,DEM.Net.Core.DEMDataSet,DEM.Net.Core.InterpolationMode)">
            <summary>
            High level method that retrieves all dataset elevations along given line
            </summary>
            <param name="lineWKT">Line geometry in WKT</param>
            <param name="dataSet">DEM dataset to use</param>
            <param name="interpolationMode">Interpolation mode</param>
            <remarks>Output can be BIG, as all elevations will be returned.</remarks>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.GetPointElevation(System.Double,System.Double,DEM.Net.Core.DEMDataSet,DEM.Net.Core.InterpolationMode)">
            <summary>
            High level method that retrieves elevation for given point
            </summary>
            <param name="lat">Point latitude</param>
            <param name="lon">Point longitude</param>
            <param name="dataSet">DEM dataset to use</param>
            <param name="interpolationMode">Interpolation mode</param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.GetPointElevation(DEM.Net.Core.FileMetadata,System.Double,System.Double,DEM.Net.Core.IInterpolator)">
            <summary>
            Get elevation for any raster at specified point (in raster coordinate system)
            </summary>
            <param name="metadata">File metadata, <see cref="M:DEM.Net.Core.IRasterFile.ParseMetaData"/> and <see cref="M:DEM.Net.Core.IRasterService.OpenFile(System.String,DEM.Net.Core.DEMFileFormat)"/></param>
            <param name="lat"></param>
            <param name="lon"></param>
            <param name="interpolator">If null, then Bilinear interpolation will be used</param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.GetPointElevation(DEM.Net.Core.IRasterFile,DEM.Net.Core.FileMetadata,System.Double,System.Double,DEM.Net.Core.IInterpolator)">
            <summary>
            Get elevation for any raster at specified point (in raster coordinate system)
            </summary>
            <param name="raster">Raster file, <see cref="M:DEM.Net.Core.IRasterService.OpenFile(System.String,DEM.Net.Core.DEMFileFormat)"/></param>
            <param name="metadata">File metadata, <see cref="M:DEM.Net.Core.IRasterFile.ParseMetaData"/></param>
            <param name="lat"></param>
            <param name="lon"></param>
            <param name="interpolator">If null, then Bilinear interpolation will be used</param>
            <returns></returns>
        </member>
        <!-- Commentaire XML incorrect pour le membre "M:DEM.Net.Core.IElevationService.GetPointsElevation(System.Collections.Generic.IEnumerable{DEM.Net.Core.GeoPoint},DEM.Net.Core.DEMDataSet,DEM.Net.Core.InterpolationMode)" -->
        <member name="M:DEM.Net.Core.IElevationService.GetHeightMap(DEM.Net.Core.BoundingBox,DEM.Net.Core.DEMDataSet)">
            <summary>
            Returns all elevations in given bbox
            </summary>
            <param name="bbox"></param>
            <param name="dataSet"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.GetHeightMap(DEM.Net.Core.FileMetadata)">
            <summary>
            Get all elevation for a given raster file
            </summary>
            <param name="metadata">Raster file metadata. <see cref="M:DEM.Net.Core.IElevationService.GetCoveringFiles(DEM.Net.Core.BoundingBox,DEM.Net.Core.DEMDataSet,System.Collections.Generic.List{DEM.Net.Core.FileMetadata})"></see></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.GetTilesBoundingBox(System.Collections.Generic.List{DEM.Net.Core.FileMetadata})">
            <summary>
            Retrieves bounding box for the uning of all raster file list
            </summary>
            <param name="tiles"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.IsBboxIntersectingTile(DEM.Net.Core.FileMetadata,DEM.Net.Core.BoundingBox)">
            <summary>
            Performs point / bbox intersection
            </summary>
            <param name="originLatitude"></param>
            <param name="originLongitude"></param>
            <param name="bbox"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IElevationService.ExportElevationTable(System.Collections.Generic.List{DEM.Net.Core.GeoPoint})">
            <summary>
            Generate a tab separated list of points and elevations
            </summary>
            <param name="lineElevationData"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.GeometryService.ParseGeoPointAsGeometryLine(System.Collections.Generic.IEnumerable{DEM.Net.Core.GeoPoint})">
            <summary>
            Problem here : self intersecting lines are not supported. Not ideal for GPS tracks...
            </summary>
            <param name="points"></param>
            <returns></returns>
        </member>
        <member name="T:DEM.Net.Core.Interpolation.BilinearInterpolator">
             <summary>
             Standard interpolation
             
             For a point lying between 4 nearest grid coordinates, this interpolator will do a linear interpolation on X axis and then on Y axis.
             
            
             
             "The concept of linear interpolation between two points can be extended to bilinear interpolation within 
             the grid cell. The function is said to be linear in each variable when the other is held fixed. 
             
             For example, to determine the height hi at x, y in Figure 5, the elevations at y on the vertical 
             boundaries of the grid cell can be linearly interpolated between h1 and h3 at ha, and h2 and h4 at hb.
             Finally, the required elevation at x can be linearly interpolated between ha and hb."
             
             Source : http://www.geocomputation.org/1999/082/gc_082.htm
             </summary>
        </member>
        <member name="T:DEM.Net.Core.Interpolation.HyperbolicInterpolator">
            <summary>
            HyperbolicInterpolator : gives smoother results, but can skip small flat areas
            Other implementation described briefly in article.
            
            Source : http://www.geocomputation.org/1999/082/gc_082.htm
            </summary>
        </member>
        <member name="M:DEM.Net.Core.IInterpolator.Interpolate(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            
            
            The concept of linear interpolation between two points can be extended to bilinear interpolation within 
            the grid cell. The function is said to be linear in each variable when the other is held fixed. 
            
            For example, to determine the height hi at x, y in Figure 5, the elevations at y on the vertical 
            boundaries of the grid cell can be linearly interpolated between h1 and h3 at ha, and h2 and h4 at hb.
            Finally, the required elevation at x can be linearly interpolated between ha and hb. 
            
            Source : http://www.geocomputation.org/1999/082/gc_082.htm
            </summary>
            <param name="h1"></param>
            <param name="h2"></param>
            <param name="h3"></param>
            <param name="h4"></param>
            <returns></returns>
        </member>
        <member name="T:DEM.Net.Core.Services.Lab.BeanRelationPointToFacette">
            <summary>
            Décrit un point support de facette dans le cadre spécifique de cette facette
            </summary>
        </member>
        <member name="M:DEM.Net.Core.Services.Lab.CalculServices_Low.GetEquationParametriqueDroite2D(System.Double[],System.Double[],System.Boolean)">
            <summary>
            On renvoie une matrice [ligne,colonne] telle que:
            colonne 1 contient les paramètres des x
            colonne 2 contient les paramètres des y
            ligne 1: coefficient en x et en y
            </summary>
            <param name="p_Droite1_pt1"></param>
            <param name="p_Droite1_pt2"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.Services.Lab.CalculServices_Low.IsPointDDansCercleCirconscritAuTriangleByMatrice(System.Collections.Generic.List{System.Double[]},System.Double[])">
            <summary>
            (Attention:
            - le principe de l'algo n'est pas clair 
            - + une 'pustule' inversant le résulat a été nécessaire
            </summary>
            <param name="p_pointsTriangle"></param>
            <param name="p_coordPtD"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.Services.Lab.CalculServices_Low.GetOrdonnancement(System.Collections.Generic.Dictionary{System.Int32,System.Double[]},System.Boolean,System.Boolean)">
            <summary>
            Surtout adapté aux triangles)
            </summary>
            <param name="p_pointsATester"></param>
            <param name="p_renvoyerNullSiColineaires_vf"></param>
            <param name="p_horaireSinonAntihoraire_vf"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.Services.Lab.CalculServices_Medium.GetInitialisationTin(System.Collections.Generic.List{DEM.Net.Core.Services.Lab.BeanPoint_internal},DEM.Net.Core.Services.Lab.BeanParametresDuTin)">
            <summary>
            Partant d'une liste de points de dimension '2D1/2' (2 composantes X et Y + un attribut d'élévation)
            on initialise le TIN:
            - en créant des facettes triangulaires à partir:
               -du point N d'élévation maximum
               -des points du convexhull des points projetés dans le plan P0, d'élévation constante, min des élévations
               (et excluant le point N, s'il appartient au convexhull)
            - en les 'associant' les unes aux autres par l'intermédiaire de leurs arcs partagés
              (on vt savoir, pour chaque 'facette', qu'elles sont ses 'voisines'.
            - en effectuant la partition des points entre les facettes du TIN.
            Usage: va permettre d'amorcer la recherche des points saillants.
            </summary>
            <param name="p_points"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.Services.Lab.CalculServices_Medium.RattachePointsToFacette(System.Collections.Generic.List{DEM.Net.Core.Services.Lab.BeanPoint_internal}@,DEM.Net.Core.Services.Lab.BeanFacette_internal@)">
            <summary>
            Soit, en entrée, une 'facette' et une liste de points,
            on veut identifier les points inclus dans la facette et les rattacher, par ref, à cette facette.
            ATTENTION TRES IMPORTANT: 
            Cette opération est faîte pour être répétée sur des 'sous-facettes' 
            (entendre "les 'facettes' émergeant à partir d'1 facette, par rajout d'un 'point central' pour création d'un tétraèdre").
            Or, tous les points inclus dans la facette d'origine doivent être affectés 1 fois et 1 seule à une facette (pas d'oubli, pas de doublon).
            Pour cela, on introduit une dissymétrie: 
            on présume les points ordonnés dans un sens anti-horaire et le premier point comme le 'point central'.
            Partant de là, on prend:
            tous les points STRICTEMENT à 'droite' de l'arc 'descendant' ET (à 'gauche' de l'arc 'montant' OU sur cet arc 'montant')
            Le 3ème arc -opposé au 'point central'- est considéré comme 'arc base' et on conserve tous les points au-dessus ou 'sur' lui 
            SAUF si le point est également sur l'arc descendant.
            IMPACT? Lors des créations de sous-facettes, il faut utiliser des triptyques de points tous ordonnés dans le même sens 
            (soit horaire soit anti-horaire) et il est fortement conseillé que le premier point envoyé soit le 'point central'
            </summary>
            <param name="p_pointsInclus"></param>
            <param name="p_facette"></param>
        </member>
        <member name="M:DEM.Net.Core.Services.Lab.CalculServices_Medium.GetArcsConvexesGauches(DEM.Net.Core.Services.Lab.BeanArc_internal)">
            <summary>
            Soit, en entrée, un segment de droite orienté S1 et un nuage de points N, décrits dans un BeanArc
            On veut génèrer 2 nouveaux arcs S2 et S3 tels que:
            S2 débute au premier point de S1, joigne le point Nx de N le plus éloigné orthogonalement, à gauche, de S1 avec une distance strictement >0
            S3 débute en Nx et aboutisse au dernier de S1
            S'il n'existe aucun point 'à gauche' de S1=>on retourne null.
            Attention: il n'y a pas de contrôle que le projeté de Nx sur S1 est inclus dans le segment S1.
            Usage originel de la méthode: génération du convexhull
            </summary>
            <param name="p_arcEnrichiSource"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.Services.Lab.CalculServices_Medium.GetCoordonneesDansNewReferentiel2D(System.Collections.Generic.IEnumerable{DEM.Net.Core.Services.Lab.BeanPoint_internal},System.Double[],System.Double[],System.Double[])">
            <summary>
            Transpose les 'points à référencer' dans un repère 2D:
            d'origine p_coordPoint0
            de premier vecteur directeur i: p_coordPoint0=>p_coordPoint2Abs
            de second vecteur directeur j: p_coordPoint0=>p_coordPoint3Ord_orthoSiNull OU d'un vecteur normal à i, 
              de même norme et d'origine p_coordPoint0 si p_coordPoint3Ord_orthoSiNull est null 
              SI les points du repères sont colinéaires =>renvoie null
            </summary>
            <param name="p_pointsAReferencer"></param>
            <param name="p_coordPointOrigine"></param>
            <param name="p_coordPoint2Abs"></param>
            <param name="p_coordPoint3Ord_orthoSiNull"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.Services.Lab.ICalculServices_Medium.GetInitialisationTin(System.Collections.Generic.List{DEM.Net.Core.Services.Lab.BeanPoint_internal},DEM.Net.Core.Services.Lab.BeanParametresDuTin)">
            <summary>
            
            </summary>
            <param name="p_points"></param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.Services.Lab.ICalculServices_Medium.GetConvexHull2D(System.Collections.Generic.IEnumerable{DEM.Net.Core.Services.Lab.BeanPoint_internal})">
            <summary>
            
            </summary>
            <param name="p_points"></param>
            <returns></returns>
        </member>
        <member name="F:DEM.Net.Core.Services.Mesh.BoxBaseThickness.FixedElevation">
            <summary>
            Box base is at a given elevation
            </summary>
        </member>
        <member name="F:DEM.Net.Core.Services.Mesh.BoxBaseThickness.FromMinimumPoint">
            <summary>
            Box base is calculated from the lowest Z value plus a margin
            </summary>
        </member>
        <member name="M:DEM.Net.Core.Services.Mesh.MeshService.TriangulateHeightMap(DEM.Net.Core.HeightMap,System.Boolean)">
            <summary>
            Triangulate a regular set of points
            </summary>
            <param name="heightMap">Gridded set of points. Corrdinates can differ, 
            but height map should be organized a set of rows and columns</param>
            <param name="regularTriangulation">(optional) Determines which diagnal is choosen</param>
            <returns>List of indexes (triplets) in height map coordinates, indicating each of the triangles vertices</returns>
        </member>
        <member name="M:DEM.Net.Core.Services.Mesh.MeshService.GenerateTriangleMesh_Boxed(DEM.Net.Core.HeightMap,DEM.Net.Core.Services.Mesh.BoxBaseThickness,System.Single)">
            <summary>
            Triangulate an height map and generates a base of given height
            </summary>
            <param name="heightMap">Gridded set of points. Corrdinates can differ, 
            but height map should be organized a set of rows and columns</param>
            <returns>TriangulationResult</returns>
        </member>
        <member name="M:DEM.Net.Core.Services.Mesh.MeshService.ComputeNormals(DEM.Net.Core.HeightMap)">
            <summary>
            Calculate normals for a given height map
            </summary>
            <param name="heightMap">Height map (gridded data)</param>
            <returns>Normals for each point of the height map</returns>
        </member>
        <member name="M:DEM.Net.Core.Services.VisualisationServices.IStatsPopulationServices.GetPointsParClasseOrdonnees(System.Collections.Generic.List{DEM.Net.Core.Services.Lab.BeanPoint_internal},System.Int32,DEM.Net.Core.Services.VisualisationServices.enumModeSeuillage)">
            <summary>
            Permet de faire des regroupements des points dans des classes en fonction de leur valeur d'élévation.
            </summary>
            <param name="p_points"></param>
            <param name="p_nbreClasses"></param>
            <param name="p_modeSeuillage"></param>
            <returns></returns>
        </member>
        <member name="T:DEM.Net.Core.GDALVRTFileService">
            <summary>
            Remote GDAL VRT file handling
            Downloads and enumerates through tiles referenced in VRT file
            </summary>
        </member>
        <member name="M:DEM.Net.Core.GDALVRTFileService.Setup(System.Boolean)">
            <summary>
            Ensures local directories are created and download VRT file if needed
            </summary>
        </member>
        <member name="M:DEM.Net.Core.GDALVRTFileService.Sources">
            <summary>
            Enumerates throught all the sources
            Supports only VRTRasterBand with ComplexSource or SimpleSource
            </summary>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.IRasterService.GenerateDirectoryMetadata(DEM.Net.Core.DEMDataSet,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Generate metadata files for fast in-memory indexing
            </summary>
            <param name="dataSet"></param>
            <param name="generateBitmaps">If true, bitmaps with height map will be generated (heavy memory usage and waaaay slower)</param>
            <param name="force">If true, force regeneration of all files. If false, only missing files will be generated.</param>
            <param name="deleteOnError">If true, files where error are encountered will be deleted</param>
        </member>
        <member name="M:DEM.Net.Core.IRasterService.GenerateReport(DEM.Net.Core.DEMDataSet,DEM.Net.Core.BoundingBox)">
            <summary>
            Compare LST file and local directory and generates dictionary with key : remoteFile and value = true if file is present and false if it is not downloaded
            </summary>
            <param name="dataSet">DEM dataset information</param>
            <param name="bbox">Bbox for filtering</param>
            <returns></returns>
        </member>
        <member name="M:DEM.Net.Core.RasterService.GenerateDirectoryMetadata(DEM.Net.Core.DEMDataSet,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Generate metadata files for fast in-memory indexing
            </summary>
            <param name="directoryPath">Raster files directory</param>
            <param name="generateBitmaps">If true, bitmaps with height map will be generated (heavy memory usage and waaaay slower)</param>
            <param name="force">If true, force regeneration of all files. If false, only missing files will be generated.</param>
        </member>
        <member name="M:DEM.Net.Core.Smoothing.WindowSmooth(System.Collections.Generic.List{DEM.Net.Core.GeoPoint},System.Double[])">
            <summary>
            WindowSmooth
            Source : https://github.com/Andy9FromSpace/map-elevation
            </summary>
            <param name="nodes"></param>
            <param name="smoothingFilter">test with new float[] { 0.1f, 1f, 0.1f } for 1arc /second</param>
        </member>
        <member name="M:DEM.Net.Core.Smoothing.FeedbackSmooth(System.Collections.Generic.List{DEM.Net.Core.GeoPoint},System.Single,System.Single)">
            <summary>
            FeedbackSmooth
            Source : https://github.com/Andy9FromSpace/map-elevation
            </summary>
            <param name="nodes"></param>
            <param name="smoothingFilter">test with 1, 3 for 1arc /second</param>
        </member>
    </members>
</doc>
